\chapter{Introduction}
% 1. single machine replication
% 2. state machine replication
% 2.1 weak determinism, total order of synchronization primitives.
% 3. contribution
% 3.1 deterministic execution and schedule replication inside kernel
% 3.2 fully transparent, minimal modification to application
% 3.3 comparision that sched rep is better

% cite a bunch of intra-machine solutions
% Hypervisor-based Fault-tolerance
% Operating System Support for Redundant Multithreading
% Tardigrade: Leveraging Lightweight Virtual Machines to Easily and Efficiently Construct Fault-Tolerant Services


%With increasing number of CPU cores and memory size, multi-threaded and multi-process applications are widely adopt to extract the full potential of such high performance multi-core machines. 

Nowadays semiconductor industry pushes the CPU core count day by day. Having a computer system with high CPU core count and large memory capacity is cheaper than ever before. However with the technology advances, we still cannot ignore the fact that computer systems suffer from manifold failures time to time. Especially transient fault in a sophisticated computer system can cause memory and CPU cores to fail. Current SMP operating systems are usually fragile to such failures. A faulty device, a CPU failure or a memory damage usually lead to the entire system to crash. To be able to recovery from such severe failures, having backup machines is always a good idea. When the primary machine fails, the backup machines are set to be able to take over the previous work and carry on the services.

State machine replication (SMR) has been widely used for fault-tolerance replication . In SMR, it models the services to be replicated with a set of inputs, a set of outputs and a set of states. The replication system ensures that for a given input set, from the same initial state, the replicas can produces the same state transition which in turn leads to the same output. Such a system is able to be resilient to failures in one or more replicas (depends on how many replicas are there in the system). To provide such property, determinism is required for the state machine, otherwise state machines will get diverged in different states even with the same input set.

With the idea of SMR, there are a good amount of works that allows users to have multiple machines to act as replicas ~\cite{cui2015p}~\cite{zagorodnov2009practical}~\cite{singh2009zeno}~\cite{mao2008mencius}. While these solutions requires additional machines to do the replication, some works have explored the possibility of doing replication inside the same machine. In ~\cite{zhang2012runtime} and ~\cite{lee2010respec}, they proposed replication systems that can have a redundant execution instance along with the original one. But doing the replication inside the same OS cannot mitigate a transient fault that could fail the entire OS. To have a full stack replication that can minimize the impact of an OS failure, several works have investigated the approaches of doing replication via virtualization~\cite{bressoud1996hypervisor}~\cite{lorch2015tardigrade}~\cite{dunlap2002revirt}. However, such solutions can still suffer from the faults happen in the hypervisor.

Multi-kernel

% ~\cite{zhang2012runtime}
% A section for server applications
% Practical and Low-Overhead Masking of Failures of TCP-Based Servers

\section{Contributions}

This thesis presents the following contributions:

\begin{itemize}
\item To synchronize thread inter-leavings of replicated concurrent applications, based on Popcorn Linux, we implemented two different replication modes in the kernel, Deterministic Execution and Schedule Replication. Both of them achieved the same goal in two different directions: Deterministic Execution uses a deterministic algorithm to decide the order of execution on both primary and secondary; while Schedule Replication enforces the secondary replica to follow the non-deterministic execution order that happened previously on the primary kernel.

\item We provide a common programming interface for both replication modes. By wrapping a code section with our \detstart\ and \detend\ system calls, the execution order of wrapped sections can be the synchronized on both primary and secondary kernel. Based on this common interface, we also implemented a set of runtime supports that allows the user to run applications on our system with minimal code modification.

\item To explore the pros and cons for both replication modes, we evaluated different types of concurrent applications on our system. For computational application we had maximum 63.39\% slowdown for Deterministic Execution and maximum 36.3\% slowdown for Schedule Replication. For two web servers we had maximum 25.22\% slowdown for Deterministic Execution and maximum 1.96\% slowdown for Schedule Replication. Both replication modes achieved decent overhead for production use, but Schedule Replication is the better replication mode for most of our use case, in terms of both simplicity and lower overall overhead.
\end{itemize}

\section{Thesis Organization}
This thesis is organized as follows:

Chapter 2 presents the background of Popcorn Linux, which is the multi-kernel system we are using for building our intra-machine replication.

Chapter 3 presents our first replication mode, Deterministic Execution. 

Chapter 4 presents our second replication mode, Schedule Replication.

Chapter 5 presents the additional runtime support that we implemented to eliminate some residual non-deterministic issues, and a runtime library to simplify the application deployment on our system.

Chapter 6 shows the performance evaluation of our system on multiple concurrent real world applications.

Chapter 7 concludes the work and discusses some future works.