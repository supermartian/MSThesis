\chapter{Introduction}
% 1. single machine replication
% 2. state machine replication
% 2.1 weak determinism, total order of synchronization primitives.
% 3. contribution
% 3.1 deterministic execution and schedule replication inside kernel
% 3.2 fully transparent, minimal modification to application
% 3.3 comparision that sched rep is better

% cite a bunch of intra-machine solutions
% Hypervisor-based Fault-tolerance
% Operating System Support for Redundant Multithreading
% Tardigrade: Leveraging Lightweight Virtual Machines to Easily and Efficiently Construct Fault-Tolerant Services


%With increasing number of CPU cores and memory size, multi-threaded and multi-process applications are widely adopt to extract the full potential of such high performance multi-core machines. 

Nowadays semiconductor industry has pushed the CPU core count to a historical high level. Having a computer system with high CPU core count and large memory capacity is cheaper than ever before. However with the technology advances, we still cannot ignore the fact that computer systems suffer from manifold failures time to time. Especially transient fault in a sophisticated computer system can cause memory and CPU cores to fail. Current SMP operating systems are usually fragile to such failures. A faulty device, a CPU failure or a memory damage usually lead to the entire system to crash. To be able to recovery from such severe failures, having backup machines is always a good idea. When the primary machine fails, the backup machines are set to be able to take over the previous work and carry on the services.

With the idea of replication, there are a good amount of works that allows users to have multiple machines to act as replicas ~\cite{cui2015p}~\cite{zagorodnov2009practical}~\cite{singh2009zeno}~\cite{mao2008mencius}. While these solutions requires additional machines to do the replication, some works have explored the possibility of doing replication inside the same machine. This kind of systems are perfect for faults that will fail the applications but not the entire machine. In ~\cite{zhang2012runtime} and ~\cite{lee2010respec}, they proposed replication systems that can have a redundant execution instance along with the original one. But doing the replication inside the same OS still cannot mitigate a transient fault that could fail the entire OS. To have a full stack replication that can minimize the impact of an OS failure, several works have investigated the approaches of doing replication via virtualization~\cite{bressoud1996hypervisor}~\cite{lorch2015tardigrade}~\cite{dunlap2002revirt}. However, such solutions can still suffer from the faults happen in the hypervisor.

To achieve resilient fault-tolerance replication inside a single machine, we have to provide strong isolation for all the replicas. Multi-kernel~\cite{baumann2009multikernel}~\cite{barbalace2014popcorn} provides a promising idea of running multiple OS kernels on a multi-core system without the support of a hypervisor. On a multi-kernel OS, each kernel has its own dedicated CPU cores and memory sections, the kernels can communicate with each other via messages. While multi-kernel OSes are designed to explore new means of extracting multi-core performance for concurrent applications, we found this kind of OSes can provide strong isolation for OSes and fits perfectly for fault-tolerance replication. The Popcorn Linux~\cite{barbalace2014popcorn} project is a research effort aimed at building scalable systems software for future generations of heterogeneous and homogeneous multi/many-core architectures. As a multi-kernel OS, Popcorn Linux is able to host multiple Linux instances simultaneously on a multi-core machine. Building a SMR system that utilizes multiple Linux instances on Popcorn Linux is the perfect solution for doing intra-machine replication. In this intra-machine replication model, the transient fault on one kernel instance can hardly get propagated to others.

State machine replication (SMR) has been widely used for fault-tolerance replication . In SMR, it models the services to be replicated with a set of inputs, a set of outputs and a set of states. The replication system ensures that for a given input set, from the same initial state, the replicas can produces the same state transition which in turn leads to the same output. Such a system is able to be resilient to failures in one or more replicas (depends on how many replicas are there in the system). To provide such property, determinism is required for the state machine, otherwise state machines will get diverged in different states even with the same input set.

In this thesis, we have built a Primary-Backup SMR system on top of Popcorn Linux. In our system, we have a kernel instance as the primary replica and another kernel instance as the secondary replica. We model the state of a concurrent application by its system call output and thread/process inter-leavings. By synchronizing the system call output and thread/process inter-leavings across all the replicas, we can make sure that the replicated applications can have consistent outputs on both primary and secondary.

% ~\cite{zhang2012runtime}
% A section for server applications
% Practical and Low-Overhead Masking of Failures of TCP-Based Servers

\section{Contributions}

This thesis presents the following contributions:

\begin{itemize}
\item To synchronize thread inter-leavings of replicated concurrent applications, based on Popcorn Linux, we implemented two different replication modes in the kernel, Deterministic Execution and Schedule Replication. Both of them achieved the same goal in two different directions: Deterministic Execution uses a deterministic algorithm to decide the order of execution on both primary and secondary; while Schedule Replication enforces the secondary replica to follow the non-deterministic execution order that happened previously on the primary kernel.

\item We provide a common programming interface for both replication modes. By wrapping a code section with our \detstart\ and \detend\ system calls, the execution order of wrapped sections can be the synchronized on both primary and secondary kernel. Based on this common interface, we also implemented a set of runtime supports that allows the user to run applications on our system with minimal code modification.

\item To explore the pros and cons for both replication modes, we evaluated different types of concurrent applications on our system. For computational application we had maximum 63.39\% slowdown for Deterministic Execution and maximum 36.3\% slowdown for Schedule Replication. For two web servers we had maximum 25.22\% slowdown for Deterministic Execution and maximum 1.96\% slowdown for Schedule Replication. Both replication modes achieved decent overhead for production use, but Schedule Replication is the better replication mode for most of our use case, in terms of both simplicity and lower overall overhead.
\end{itemize}

\section{Scope}
This thesis mainly discusses about how to ensure the same thread/process inter-leavings across the replicas, and some key system calls to ensure the consistent state of server applications. We do not address the non-determinism from signal, file system, random number generator. For the replication of server applications, a member of SSRG has already implemented the replication of the TCP stack and connection recovery from kernel failures, which was able to support replication for single-threaded applications prior to this work. On top of that, the work described in this thesis provides the ability of replicating multi-threaded/multi-process server applications.

\section{Thesis Organization}
This thesis is organized as follows:

Chapter 2 presents the background of Popcorn Linux, which is the multi-kernel system we are using for building our intra-machine replication.

Chapter 3 presents our first replication mode, Deterministic Execution. 

Chapter 4 presents our second replication mode, Schedule Replication.

Chapter 5 presents the additional runtime support that we implemented to eliminate some residual non-deterministic issues, and a runtime library to simplify the application deployment on our system.

Chapter 6 shows the performance evaluation of our system on multiple concurrent real world applications.

Chapter 7 concludes the work and discusses some future works.